<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<script defer src="index.js"></script>
		<title>Document</title>
	</head>
	<body>
		<p style="display: inline; margin: 20px" id="log-message"></p>
		<textarea
			style="display: block; margin-top: 20px; opacity: 0.01"
			name=""
			id="copy-text"
		>
Команды SQL
Стандартными командами для взаимодействия с РБД являются CREATE, SELECT, INSERT, UPDATE, DELETE и DROP. Эти команды могут быть классифицированы следующим образом:

DDL - язык определения данных (Data Definition Language)
N	Команда	Описание
1	CREATE	Создает новую таблицу, представление таблицы или другой объект в БД
2	ALTER	Модифицирует существующий в БД объект, такой как таблица
3	DROP	Удаляет существующую таблицу, представление таблицы или другой объект в БД
DML - язык изменения данных (Data Manipulation Language)
N	Команда	Описание
1	SELECT	Извлекает записи из одной или нескольких таблиц
2	INSERT	Создает записи
3	UPDATE	Модифицирует записи
4	DELETE	Удаляет записи



Вот пример таблицы с пользователями (users):

userId	userName	age	city	status
1	Igor	25	Moscow	active
2	Vika	26	Ekaterinburg	inactive
3	Elena	27	Ekaterinburg	active
4	Oleg	28	Moscow	inactive

Среди наиболее распространенных ограничений можно назвать следующие:

NOT NULL - колонка не может иметь значение NULL
DEFAULT - значение колонки по умолчанию
UNIQUE - все значения колонки должны быть уникальными
PRIMARY KEY - первичный или основной ключ, уникальный идентификатор записи в текущей таблице
FOREIGN KEY - внешний ключ, уникальный идентификатор записи в другой таблице (таблице, связанной с текущей)
CHECK - все значения в колонке должны удовлетворять определенному условию

Нормализация БД
Нормализация - это процесс эффективной организации данных в БД. Существует две главных причины, обуславливающих необходимость нормализации:

предотвращение записи в БД лишних данных, например, хранения одинаковых данных в разных таблицах
обеспечение "оправданной" связи между данными
Нормализация предполагает соблюдение нескольких форм. Форма - это формат структурирования БД. 


Примеры синтаксиса

-- выборка
SELECT col1, col2, ...colN
FROM tableName;

SELECT DISTINCT col1, col2, ...colN
FROM tableName;

SELECT col1, col2, ...colN
FROM tableName
WHERE condition;

SELECT col1, col2, ...colN
FROM tableName
WHERE condition1 AND|OR condition2;

SELECT col2, col2, ...colN
FROM tableName
WHERE colName IN (val1, val2, ...valN);

SELECT col1, col2, ...colN
FROM tableName
WHERE colName BETWEEN val1 AND val2;

SELECT col1, col2, ...colN
FROM tableName
WHERE colName LIKE pattern;

SELECT col1, col2, ...colN
FROM tableName
WHERE condition
ORDER BY colName [ASC|DESC];

SELECT SUM(colName)
FROM tableName
WHERE condition
GROUP BY colName;

SELECT COUNT(colName)
FROM tableName
WHERE condition;

SELECT SUM(colName)
FROM tableName
WHERE condition
GROUP BY colName
HAVING (function condition);

-- создание таблицы
CREATE TABLE tableName (
  col1 datatype,
  col2 datatype,
  ...
  colN datatype,
  PRIMARY KEY (одна или более колонка)
);

-- удаление таблицы
DROP TABLE tableName;

-- очистка таблицы
TRUNCATE TABLE tableName;

-- добавление/удаление/модификация колонок
ALTER TABLE tableName ADD|DROP|MODIFY colName [datatype];

-- переименование таблицы
ALTER TABLE tableName RENAME TO newTableName;

-- вставка значений
INSERT INTO tableName (col1, col2, ...colN)
VALUES (val1, val2, ...valN)

-- обновление записей
UPDATE tableName
SET col1 = val1, col2 = val2, ...colN = valN
[WHERE condition];

-- удаление записей
DELETE FROM tableName
WHERE condition;

-- создание БД
CREATE DATABASE [IF NOT EXISTS] dbName;

-- удаление БД
DROP DATABASE [IF EXISTS] dbName;

-- завершения транзакции
COMMIT;

-- отмена изменений
ROLLBACK;

Типы данных
Каждая колонка, переменная и выражение в SQL имеют определенный тип данных (data type). Основные категории типов данных:

Точные числовые

Тип данных	От	До
bigint	-9,223,372,036,854,775,808	9,223,372,036,854,775,807
int	-2,147,483,648	2,147,483,647
smallint	-32,768	32,767
tinyint	0	255
bit	0	1
decimal	-10^38 +1	10^38 -1
numeric	-10^38 +1	10^38 -1
money	-922,337,203,685,477.5808	+922,337,203,685,477.5807
smallmoney	-214,748.3648	+214,748.3647
Приблизительные числовые

Тип данных	От	До
float	-1.79E + 308	1.79E + 308
real	-3.40E + 38	3.40E + 38
Дата и время

Тип данных	От	До
datetime	Jan 1, 1753	Dec 31, 9999
smalldatetime	Jan 1, 1900	Jun 6, 2079
date	Дата сохраняется в виде June 30, 1991	
time	Время сохраняется в виде 12:30 P.M.	
Строковые символьные

N	Тип данных	Описание
1	char	Строка длиной до 8,000 символов (не-юникод символы, фиксированной длины)
2	varchar	Строка длиной до 8,000 символов (не-юникод символы, переменной длины)
3	text	Не-юникод данные переменной длины, длиной до 2,147,483,647 символов
Строковые символьные (юникод)

N	Тип данных	Описание
1	nchar	Строка длиной до 4,000 символов (юникод символы, фиксированной длины)
2	nvarchar	Строка длиной до 4,000 символов (юникод символы, переменной длины)
3	ntext	Юникод данные переменной длины, длиной до 1,073,741,823 символов
Бинарные

N	Тип данных	Описание
1	binary	Данные размером до 8,000 байт (фиксированной длины)
2	varbinary	Данные размером до 8,000 байт (переменной длины)
3	image	Данные размером до 2,147,483,647 байт (переменной длины)
Смешанные

N	Тип данных	Описание
1	timestamp	Уникальные числа, обновляющиеся при каждом изменении строки
2	uniqueidentifier	Глобально-уникальный идентификатор (GUID)
3	cursor	Объект курсора
4	table	Промежуточный результат, предназначенный для дальнейшей обработки

Арифметические
Оператор	Описание	Пример
+ (сложение)	Сложение значений	a + b = 30
- (вычитание)	Вычитание правого операнда из левого	b - a = 10
* (умножение)	Умножение значений	a * b = 200
/ (деление)	Деление левого операнда на правый	b / a = 2
% (деление с остатком/по модулю)	Деление левого операнда на правый с остатком (возвращается остаток)	b % a = 0

Операторы сравнения
Оператор	Описание	Пример
=	Определяет равенство значений	a = b -> false
!=	Определяет НЕравенство значений	a != b -> true
<\>	Определяет НЕравенство значений	a <\> b -> true
>	Значение левого операнда больше значения правого операнда?	a > b -> false
<	Значение левого операнда меньше значения правого операнда?	a < b -> true
>=	Значение левого операнда больше или равно значению правого операнда?	a >= b -> false
<=	Значение левого операнда меньше или равно значению правого операнда?	a <= b -> true
!<	Значение левого операнда НЕ меньше значения правого операнда?	a !< b -> false
!>	Значение левого операнда НЕ больше значения правого операнда?	a !> b -> true
Логические операторы

N	Оператор	Описание
1	ALL	Сравнивает все значения
2	AND	Объединяет условия (все условия должны совпадать)
3	ANY	Сравнивает одно значение с другим, если последнее совпадает с условием
4	BETWEEN	Проверяет вхождение значения в диапазон от минимального до максимального
5	EXISTS	Определяет наличие строки, соответствующей определенному критерию
6	IN	Выполняет поиск значения в списке значений
7	LIKE	Сравнивает значение с похожими с помощью операторов подстановки
8	NOT	Инвертирует (меняет на противоположное) смысл других логических операторов, например, NOT EXISTS, NOT IN и т.д.
9	OR	Комбинирует условия (одно из условий должно совпадать)
10	IS NULL	Определяет, может ли поле иметь значение NULL
11	UNIQUE	Определяет уникальность строки

Базовый синтаксис выражения выглядит так:

SELECT col1, col2, ...colN
FROM tableName
WHERE [condition|expression];

Существуют различные типы выражений: логические, числовые и выражения для работы с датами.

Логические

Логические выражения извлекают данные на основе совпадения с единичным значением.

SELECT col1, col2, ...colN
FROM tableName
WHERE выражение для поиска совпадения с единичным значением;

Предположим, что в таблице users имеются следующие записи:

userId	userName	age	city	status
1	Igor	25	Moscow	active
2	Vika	26	Ekaterinburg	inactive
3	Elena	27	Ekaterinburg	active
4	Oleg	28	Moscow	inactive
Выполняем поиск активных пользователей:

SELECT * FROM users WHERE status = active;

Результат:

userId	userName	age	city	status
1	Igor	25	Moscow	active
3	Elena	27	Ekaterinburg	active
Числовые

Используются для выполнения арифметических операций в запросе.

SELECT numericalExpression as operationName
[FROM tableName
WHERE condition];

Простой пример использования числового выражения:

SELECT (10 + 5) AS addition;

Результат:

addition
15
Существует несколько встроенных функций, таких как count(), sum(), avg(), min(), max() и др. для выполнения так называемых агрегирующих вычислений данных таблицы или колонки.

SELECT COUNT(*) AS records FROM users;

Результат:

records
4
AVG - вычисляет среднее значение
SUM - вычисляет сумму значений
MIN - вычисляет наименьшее значение
MAX - вычисляет наибольшее значение
COUNT - вычисляет количество записей в таблице
Также существует несколько встроенных функций для работы со строками:

CONCAT - объединение строк
LENGTH - возвращает количество символов в строке
TRIM - удаляет пробелы в начале и конце строки
SUBSTRING - извлекает подстроку из строки
REPLACE - заменяет подстроку в строке
LOWER - переводит символы строки в нижний регистр
UPPER - переводит символы строки в верхний регистр и т.д.
с числами:

ROUND - округляет число
TRUNCATE - обрезает дробное число до указанного количества знаков после запятой
CEILING - возвращает наименьшее целое число, которое больше или равно текущему значению
FLOOR - возвращает наибольшее целое число, которое меньше или равно текущему значению
POWER - возводит число в указанную степень
SQRT - возвращает квадратный корень числа
RAND - генерирует случайное число с плавающей точкой в диапазоне от 0 до 1
Выражения для работы с датами

Эти выражения, как правило, возвращают текущую дату и время.

SELECT CURRENT_TIMESTAMP;

Результат:

Current_Timestamp
2021-06-20 12:45:00
CURRENT_TIMESTAMP - это и выражение, и функция (CURRENT_TIMESTAMP()).

Другие функции для получения текущей даты и времени:

CURDATE/CURRENT_DATE - возвращает текущую дату
CURTIME/CURRENT_TIME - возвращает текущее время и т.д.
Функции для разбора даты и времени:

DAYOFMONTH(date) - возвращает день месяца в виде числа
DAYOFWEEK(date) - возвращает день недели в виде числа
DAYOFYEAR(date) - возвращает номер дня в году
MONTH(date) - возвращает месяц
YEAR(date) - возвращает год
LAST_DAY(date) - возвращает последний день месяца в виде даты
HOUR(time) - возвращает час
MINUTE(time) - возвращает минуты
SECOND(time) - возвращает секунды и др.
Функции для манипулирования датами:

DATE_ADD(date, interval) - выполняет сложение даты и определенного временного интервала
DATE_SUB(date, interval) - выполняет вычитание из даты определенного временного интервала
DATEDIFF(date1, date2) - возвращает разницу в днях между двумя датами
TO_DAYS(date) - возвращает количество дней с 0-го дня года
TIME_TO_SEC(time) - возвращает количество секунд с полуночи и др.
Для форматирования даты и времени используются функции DATE_FORMAT(date, format) и TIME_FORMAT(date, format), соответственно.


Для получения списка таблиц используется инструкция SHOW TABLES.

Результат:

Database
information_schema
postgres
Выбор БД
При наличии нескольких БД, перед выполнением каких-либо операций, необходимо выбрать БД. Для этого используется инструкция USE.

USE dbName;

Предположим, что мы не удаляли testDB. Тогда мы можем выбрать ее так:

USE testDB;

Создание таблицы
Создание таблицы предполагает указание названия таблицы и определение колонок таблицы и их типов данных. Для создания таблицы используется инструкция CREATE TABLE.

CREATE TABLE tableName (
  col1 datatype,
  col2 datatype,
  ...
  colN datatype,
  PRIMARY KEY (хотя бы одна колонка)
);

Для создания таблицы путем копирования другой таблицы используется сочетание CREATE TABLE и SELECT.

Пример создания таблицы users, где первичным ключом являются идентификаторы пользователей, а поля для имени и возраста пользователя не могут иметь значение NULL:

CREATE TABLE users (
  userId INT,
  userName VARCHAR(20)  NOT NULL,
  age INT           NOT NULL,
  city VARCHAR(20),
  status VARCHAR(8),
  PRIMARY KEY (id)
);

Проверяем, что таблица была создана:

DESC users;

Результат:

Field	Type	Null	Key	Default	Extra
userId	int(11)	NO	PRI		
userName	varchar(20)	NO			
age	int(11)	NO			
city	varchar(20)	NO			
status	varchar(8)	YES		NULL	
Удаление таблицы
Для удаления таблицы используется инструкция DROP TABLE.

Обратите внимание: при удалении таблицы, навсегда удаляются все хранящиеся в ней данные, индексы, триггеры, ограничения и разрешения, так что будьте предельно внимательны при использовании данной команды.

Удаляем таблицу users:

DROP TABLE users;

Теперь, если мы попытаемся получить описание users, то получим ошибку:

DESC users;
-- ERROR 1146 (42S02): Table 'testDB.users' doesn't exist

Добавление колонок
Для добавления в таблицу колонок используется инструкция INSERT INTO.

INSERT INTO tableName (col1, col2, ...colN)
VALUES (val1, val2, ...valN);

Названия колонок можно не указывать, однако, в этом случае значения должны перечисляться в правильном порядке.

INSERT INTO tableName VALUES (val1, val2, ...valN);

Во избежание ошибок, рекомендуется всегда перечислять названия колонок.

Предположим, что мы не удаляли таблицу users. Заполним ее пользователями:

INSERT INTO users (userId, userName, age, city, status)
VALUES (1, 'Igor', 25, 'Moscow', 'active');

INSERT INTO users (userId, userName, age, city, status)
VALUES (2, 'Vika', 26, 'Ekaterinburg', 'inactive');

INSERT INTO users (userId, userName, age, city, status)
VALUES (3, 'Elena', 27, 'Ekaterinburg', 'active');

В таблицу можно добавлять несколько строк за один раз.

INSERT INTO users (userId, userName, age, city, status)
VALUES
(1, 'Igor', 25, 'Moscow', 'active'),
(2, 'Vika', 26, 'Ekaterinburg', 'inactive'),
(3, 'Elena', 27, 'Ekaterinburg', 'active');

Также, как было отмечено, при добавлении строки названия полей можно опускать:

INSERT INTO users
VALUES (4, 'Oleg', 28, 'Moscow', 'inactive');

Результат:

userId	userName	age	city	status
1	Igor	25	Moscow	active
2	Vika	26	Ekaterinburg	inactive
3	Elena	27	Ekaterinburg	active
4	Oleg	28	Moscow	inactive
Заполнение таблицы с помощью другой таблицы

INSERT INTO tableName [(col1, col2, ...colN)]
  SELECT col1, col2, ...colN
  FROM anotherTable
  [WHERE condition];

Выборка полей
Для выборки полей из таблицы используется инструкция SELECT. Она возвращает данные в виде результирующей таблицы (результирующего набора, result-set).

SELECT col1, col2, ...colN
FROM tableName;

Для выборки всех полей используется такой синтаксис:

SELECT * FROM tableName;

Произведем выборку полей userId, userName и age из таблицы users:

SELECT userId, userName, age FROM users;

Результат:

userId	userName	age
1	Igor	25
2	Vika	26
3	Elena	27
4	Oleg	28
Предложение WHERE
Предложение WHERE используется для фильтрации возвращаемых данных. Оно используется совместно с SELECT, UPDATE, DELETE и другими инструкциями.

SELECT col1, col2, ...col2
FROM tableName
WHERE condition;

Условие (condition), которому должны удовлетворять возвращаемые записи, определяется с помощью операторов сравнения или логических операторов типа >, <, =, NOT, LIKE и т.д.

Сделаем выборку полей userId, userName и age активных пользователей:

SELECT userId, userName, age
FROM users
WHERE status = 'active';

Результат:

userId	userName	age
1	Igor	25
3	Elena	27
Сделаем выборку полей userId, age и city пользователя с именем Vika.

SELECT userId, age, city
FROM users
WHERE userName = 'Vika';

Результат:

userId	age	city
2	26	Ekaterinburg
Обратите внимание: строки в предложении WHERE должны быть обернуты в одинарные кавычки (''), а числа, напротив, указываются как есть.

Операторы AND и OR
Конъюнктивный оператор AND и дизъюнктивный оператор OR используются для соединения нескольких условий при фильтрации данных.

AND

SELECT col1, col2, ...colN
FROM tableName
WHERE condition1 AND condition2 ...AND conditionN;

Возвращаемые записи должны удовлетворять всем указанным условиям.

Сделаем выборку полей userId, userName и age активных пользователей старше 26 лет:

SELECT userId, userName, age
FROM users
WHERE status = active AND age > 26;

Результат:

userId	userName	AGE
3	Elena	27
OR

SELECT col1, col2, ...colN
FROM tableName
WHERE condition1 OR condition2 ...OR conditionN;

Возвращаемые записи должны удовлетворять хотя бы одному условию.

Сделаем выборку тех же полей неактивных пользователей или пользователей, младше 27 лет:

SELECT userId, userName, age
FROM users
WHERE status = inactive OR age < 27;

Результат:

userId	userName	age
1	Igor	25
2	Vika	26
Обновление полей
Для обновления полей используется инструкция UPDATE ... SET. Эта инструкция, обычно, используется в сочетании с предложением WHERE.

UPDATE tableName
SET col1 = val1, col2 = val2, ...colN = valN
[WHERE condition];

Обновим возраст пользователя с именем Igor:

UPDATE users
SET age = 30
WHERE username = 'Igor';

Если в данном случае опустить WHERE, то будет обновлен возраст всех пользователей.

Удаление записей
Для удаления записей используется инструкция DELETE. Эта инструкция также, как правило, используется в сочетании с предложением WHERE.

DELETE FROM tableName
[WHERE condition];

Удалим неактивных пользователей:

DELETE FROM users
WHERE status = 'inactive';

Если в данном случае опустить WHERE, то из таблицы users будут удалены все записи.

Предложения LIKE и REGEX
LIKE

Предложение LIKE используется для сравнения значений с помощью операторов с подстановочными знаками. Существует два вида таких операторов:

проценты (%)
нижнее подчеркивание (_)
% означает 0, 1 или более символов. _ означает точно 1 символ.

SELECT col1, col2, ...colN FROM tableName
WHERE col LIKE 'xxx%'
-- или
WHERE col LIKE '%xxx%'
-- или
WHERE col LIKE '%xxx'
-- или
WHERE col LIKE 'xxx_'
-- и т.д.

Примеры:

N	Инструкция	Результат
1	WHERE col LIKE 'foo%'	Любые значения, начинающиеся с foo
2	WHERE col LIKE '%foo%'	Любые значения, содержащие foo
3	WHERE col LIKE '_oo%'	Любые значения, содержащие oo на второй и третьей позициях
4	WHERE col LIKE 'f*%*%'	Любые значения, начинающиеся с f и состоящие как минимум из 1 символа
5	WHERE col LIKE '%oo'	Любые значения, оканчивающиеся на oo
6	WHERE col LIKE '_o%o'	Любые значения, содержащие o на второй позиции и оканчивающиеся на o
7	WHERE col LIKE 'f_o'	Любые значения, содержащие f и o на первой и третьей позициях, соответственно, и состоящие из трех символов
Сделаем выборку неактивных пользователей:

SELECT * FROM users
WHERE status LIKE 'in%';

Результат:

userId	userName	age	city	status
2	Vika	26	Ekaterinburg	inactive
4	Oleg	28	Moscow	inactive
Сделаем выборку пользователей 30 лет и старше:

SELECT * FROM users
WHERE age LIKE '3_';

Результат:

userId	userName	age	city	status
1	Igor	30	Moscow	active
REGEX

Предложение REGEX позволяет определять регулярное выражение, которому должна соответствовать запись.

SELECT col1, col2, ...colN FROM tableName
WHERE colName REGEXP регулярное выражение;

В регулярное выражении могут использоваться следующие специальные символы:

^ - начало строки
$ - конец строки
. - любой символ
[символы] - любой из указанных в скобках символов
[начало-конец] - любой символ из диапазона
| - разделяет шаблоны
Сделаем выборку пользователей с именами Igor и Vika:

SELECT * FROM users
WHERE userName REGEXP 'Igor|Vika';

Результат:

userId	userName	age	city	status
1	Igor	30	Moscow	active
2	Vika	26	Ekaterinburg	inactive
Предложение TOP/LIMIT/ROWNUM
Данные предложения позволяют извлекать указанное количество или процент записей с начала таблицы. Разные СУБД поддерживают разные предложения.

SELECT TOP number|percent col1, col2, ...colN
FROM tableName
[WHERE condition];

Сделаем выборку первых трех пользователей:

SELECT TOP 3 * FROM users;

Результат:

userId	userName	age	city	status
1	Igor	30	Moscow	active
2	Vika	26	Ekaterinburg	inactive
3	Elena	27	Ekaterinburg	active
В mysql:

SELECT * FROM users
LIMIT 3, [offset];

Параметр offset (смещение) определяет количество пропускаемых записей. Например, так можно извлечь первых двух пользователей, начиная с третьего:

SELECT * FROM users
LIMIT 2, 2;

В oracle:

SELECT * FROM users
WHERE ROWNUM <= 3;

Предложения ORDER BY и GROUP BY
ORDER BY

Предложение ORDER BY используется для сортировки данных по возрастанию (ASC) или убыванию (DESC). Многие СУБД по умолчанию выполняют сортировку по возрастанию.

SELECT col1, col2, ...colN
FROM tableName
[WHERE condition]
[ORDER BY col1, col2, ...colN] [ASC | DESC];

Обратите внимание: колонки для сортировки должны быть указаны в списке колонок для выборки.

Сделаем выборку пользователей, отсортировав их по городу и возрасту:

SELECT * FROM users
ORDER BY city, age;

Результат:

userId	userName	age	city	status
2	Vika	26	Ekaterinburg	inactive
3	Elena	27	Ekaterinburg	active
1	Igor	25	Moscow	active
4	Oleg	28	Moscow	inactive
Теперь выполним сортировку по убыванию:

SELECT * FROM users
ORDER BY city, age DESC;

Определим собственный порядок сортировки по убыванию:

SELECT * FROM users
ORDER BY (CASE city
  WHEN 'Ekaterinburg' THEN 1
  WHEN 'Moscow' THEN 2
ELSE 100 END) ASC, city DESC;

GROUP BY

Предложение GROUP BY используется совместно с инструкцией SELECT для группировки записей. Оно указывается после WHERE и перед ORDER BY.

SELECT col1, col2, ...colN
FROM tableName
WHERE condition
GROUP BY col1, col2, ...colN
ORDER BY col1, col2, ...colN;

Сгруппируем активных пользователей по городам:

SELECT city, COUNT(city) AS amount FROM users
WHERE status = active
GROUP BY city
ORDER BY city;

Результат:

city	amount
Ekaterinburg	2
Moscow	2
Ключевое слово DISTINCT
Ключевое слово DISTINCT используется совместно с инструкцией SELECT для возврата только уникальных записей (без дубликатов).

SELECT DISTINCT col1, col2, ...colN
FROM tableName
[WHERE condition];

Сделаем выборку городов проживания пользователей:

SELECT DISTINCT city
FROM users;

Результат:

city
Ekaterinburg
Moscow
Соединения
Соединения (joins) используются для комбинации записей двух и более таблиц.

Предположим, что кроме users, у нас имеется таблица orders с заказами пользователей следующего содержания:

orderId	date	userId	amount
101	2021-06-21 00:00:00	2	3000
102	2021-06-20 00:00:00	2	1500
103	2021-06-19 00:00:00	3	2000
104	2021-06-18 00:00:00	3	1000
Сделаем выборку полей userId, userName, age и amount из наших таблиц посредством их соединения:

SELECT userId, userName, age, amount
FROM users, orders
WHERE users.userId = orders.userId;

Результат:

userId	userName	age	amount
2	Vika	26	3000
2	Vika	26	1500
3	Elena	27	2000
3	Elena	27	1000
При соединении таблиц могут использоваться такие операторы, как =, <, >, <>, <=, >=, !=, BETWEEN, LIKE и NOT, однако наиболее распространенным является =.

Существуют разные типы объединений:

INNER JOIN - возвращает записи, имеющиеся в обеих таблицах
LEFT JOIN - возвращает записи из левой таблицы, даже если такие записи отсутствуют в правой таблице
RIGHT JOIN - возвращает записи из правой таблицы, даже если такие записи отсутствуют в левой таблице
FULL JOIN - возвращает все записи объединяемых таблиц
CROSS JOIN - возвращает все возможные комбинации строк обеих таблиц
SELF JOIN - используется для объединения таблицы с самой собой
Предложение UNION
Предложение/оператор UNION используется для комбинации результатов двух и более инструкций SELECT. При этом, возвращаются только уникальные записи.

В случае с UNION, каждая инструкция SELECT должна иметь:

одинаковый набор колонок для выборки
одинаковое количество выражений
одинаковые типы данных колонок и
одинаковый порядок колонок
Однако, они могут быть разной длины.

SELECT col1, col2, ...colN
FROM table1
[WHERE condition]

UNION

SELECT col1, col2, ...colN
FROM table2
[WHERE condition];

Объединим наши таблицы users и orders:

  SELECT userId, userName, amount, date
  FROM users
  LEFT JOIN orders
  ON users.useId = orders.userId
UNION
  SELECT userId, userName, amount, date
  FROM users
  RIGHT JOIN orders
  ON users.userId = orders.userId;

Результат:

userId	userName	amount	date
1	Igor	NULL	NULL
2	Vika	3000	2021-06-21 00:00:00
2	Vika	1500	2021-06-20 00:00:00
3	Elena	2000	2021-06-19 00:00:00
3	Elena	1000	2021-06-18 00:00:00
4	Alex	NULL	NULL
Предложение UNION ALL
Предложение UNION ALL также используется для объединения результатов двух и более инструкций SELECT. При этом, возвращаются все записи, включая дубликаты.

SELECT col1, col2, ...colN
FROM table1
[WHERE condition]

UNION ALL

SELECT col1, col2, ...colN
FROM table2
[WHERE condition];

Существует еще два предложения, похожих на UNION:

INTERSECT - используется для комбинации результатов двух и более SELECT, но возвращаются только строки из первого SELECT, совпадающие со строками из второго SELECT
EXCEPT|MINUS - возвращаются только строки из первого SELECT, отсутствующие во втором SELECT
Синонимы
Синонимы (aliases) позволяют временно изменять названия таблиц и колонок. "Временно" означает, что новое название используется только в текущем запросе, в БД название остается прежним.

Синтаксис синонима таблицы:

SELECT col1, col2, ...colN
FROM tableName AS aliasName
[WHERE condition];

Синтаксис синонима колонки:

SELECT colName AS aliasName
FROM tableName
[WHERE condition];

Пример использования синонимов таблиц:

SELECT U.userId, U.userName, U.age, O.amount
FROM users AS U, orders AS O
WHERE U.userId = O.userId;

Результат:

userId	userName	age	amount
2	Vika	26	3000
2	Vika	26	1500
3	Elena	27	2000
3	Elena	27	1000
Пример использования синонимов колонок:

SELECT userId AS user_id, userName AS user_name, age AS user_age
FROM users
WHERE status = active;

Результат:

user_id	user_name	user_age
1	Igor	30
3	Elena	27
Индексы
Создание индексов

Индексы - это специальные поисковые таблицы (lookup tables), которые используются движком БД в целях более быстрого извлечения данных. Проще говоря, индекс - это указатель или ссылка на данные в таблице.

Индексы ускоряют работу инструкции SELECT и предложения WHERE, но замедляют работу инструкций UPDATE и INSERT. Индексы могут создаваться и удаляться, не оказывая никакого влияния на данные.

Для создания индекса используется инструкция CREATE INDEX, позволяющая определять название индекса, индексируемые колонки и порядок индексации (по возрастанию или по убыванию).

К индексам можно применять ограничение UNIQUE для того, чтобы обеспечить их уникальность.

Синтаксис создания индекса:

CREATE INDEX indexName ON tableName;

Синтаксис создания индекса для одной колонки:

CREATE INDEX indexName
ON tableName (colName);

Синтакис создания уникальных индексов (такие индексы используются не только для повышения производительности, но и для обеспечения согласованности данных):

CREATE UNIQUE INDEX indexName
ON tableName (colName);

Синтаксис создания индексов для нескольких колонок (композиционный индекс):

CREATE INDEX indexName
ON tableName (col1, col2, ...colN);

Решение о создании индексов для одной или нескольких колонок следует принимать на основе того, какие колонки будут часто использоваться в запросе WHERE в качестве условия для сортировки строк.

Для ограничений PRIMARY KEY и UNIQUE автоматически создаются неявные индексы.

Удаление индексов

Для удаления индексов используется инструкция DROP INDEX:

DROP INDEX indexName;

Несмотря на то, что индексы предназначены для повышения производительности БД, существуют ситуации, в которых их использования лучше избегать.

К таким ситуациям относится следующее:

индексы не должны использоваться в маленьких таблицах
в таблицах, которые часто и в большом объеме обновляются или перезаписываются
в колонках, которые содержат большое количество значений NULL
в колонках, над которыми часто выполняются операции
Обновление таблицы
Команда ALTER TABLE используется для добавления, удаления и модификации колонок существующей таблицы. Также эта команда используется для добавления и удаления ограничений.

Синтаксис:

-- добавление новой колонки
ALTER TABLE tableName ADD colName datatype;

-- удаление колонки
ALTER TABLE tableName DROP COLUMN colName;

-- изменение типа данных колонки
ALTER TABLE tableName MODIFY COLUMN colName newDatatype;

-- добавление ограничения `NOT NULL`
ALTER TABLE tableName MODIFY colName datatype NOT NULL;

-- добавление ограничения `UNIQUE`
ALTER TABLE tableName
ADD CONSTRAINT myUniqueConstraint UNIQUE (col1, col2, ...colN);

-- добавление ограничения `CHECK`
ALTER TABLE tableName
ADD CONSTRAINT myUniqueConstraint CHECK (condition);

-- добавление первичного ключа
ALTER TABLE tableName
ADD CONSTRAINT myPrimaryKey PRIMARY KEY (col1, col2, ...colN);

-- удаление ограничения
ALTER TABLE tableName
DROP CONSTRAINT myUniqueContsraint;

-- mysql
ALTER TABLE tableName
DROP INDEX myUniqueContsraint;

-- удаление первичного ключа
ALTER TABLE tableName
DROP CONSTRAINT myPrimaryKey;

-- mysql
ALTER TABLE tableName
DROP PRIMARY KEY;

Добавляем в таблицу users новую колонку - пол пользователя:

ALTER TABLE users ADD sex char(1);

Удаляем эту колонку:

ALTER TABLE users DROP sex;

Очистка таблицы
Команда TRUNCATE TABLE используется для очистки таблицы. Ее отличие от DROP TABLE состоит в том, что сохраняется структура таблицы (DROP TABLE полностью удаляет таблицу и все ее данные).

TRUNCATE TABLE tableName;

Очищаем таблицу users:

TRUNCATE TABLE users;

Проверяем, что users пустая:

SELECT * FROM users;
-- Empty set (0.00 sec)

Представления
Представление (view) - это не что иное, как инструкция, записанная в БД под определенным названием. Другими словами, представление - это композиция таблицы в форме предварительно определенного запроса.

Представления могут содержать все или только некоторые строки таблицы. Представление может быть создано на основе одной или нескольких таблиц (это зависит от запроса для создания представления).

Представления - это виртутальные таблицы, позволяющие делать следующее:

структурировать данные способом, который пользователи находят наиболее естественным или интуитивно понятным
ограничивать доступ к данным таким образом, что пользователь может просматривать и (иногда) модифицировать только то, что ему нужно и ничего более
объединять данные из нескольких таблиц для формирования отчетов
Создание представления

Для создания представления используется инструкция CREATE VIEW. Как было отмечено, представления могут создаваться на основе одной или нескольких таблиц, и даже на основе другого представления.

CREATE VIEW viewName AS
SELECT col1, col2, ...colN
FROM tableName
[WHERE condition];

Создаем представление для имен и возраста пользователей:

CREATE VIEW usersView AS
SELECT userName, age
FROM users;

Получаем данные с помощью представления:

SELECT * FROM usersView;

Результат:

userName	age
Igor	30
Vika	26
Elena	27
Oleg	28
WITH CHECK OPTION

WITH CHECK OPTION - это настройка инструкции CREATE VIEW. Она позволяет обеспечить соответствие всех UPDATE и INSERT условию, определенном в представлении.

Если условие не удовлетворяется, выбрасывается исключение.

CREATE VIEW usersView AS
SELECT userName, age
FROM users
WHERE age IS NOT NULL
WITH CHECK OPTION;

Обновление представления

Представление может быть обновлено при соблюдении следующих условий:

SELECT не содержит ключевого слова DISTINCT
SELECT не содержит агрегирующих функций
SELECT не содержит функций установки значений
SELECT не содержит операций установки значений
SELECT не содержит предложения ORDER BY
FROM не содержит больше одной таблицы
WHERE не содержит подзапросы
запрос не содержит GROUP BY или HAVING
вычисляемые колонки не обновляются
все ненулевые колонки из базовой таблицы включены в представление в том же порядке, в каком они указаны в запросе INSERT
Пример обновления возраста пользователя с именем Igor в представлении:

UPDATE usersView
SET age = 31
WHERE userName = 'Igor';

Обратите внимание: обновление строки в представлении приводит к ее обновлению в базовой таблице.

В представление могут добавляться новые строки с помощью команды INSERT. При выполнении этой команды должны соблюдаться те же правила, что и при выполнении команды UPDATE.

С помощью команды DELETE можно удалять строки из представления.

Удаляем из представления пользователя, возраст которого составляет 26 лет:

DELETE FROM usersView
WHERE age = 26;

Обратите внимание: удаление строки в представлении приводит к ее удалению в базовой таблице.

Удаление представления

Для удаления представления используется инструкция DROP VIEW:

DROP VIEW viewName;

Удаляем представление usersView:

DROP VIEW usersView;

HAVING
Предложение HAVING используется для фильтрации результатов группировки. WHERE используется для применения условий к колонкам, а HAVING - к группам, созданным с помощью GROUP BY.

HAVING должно указываться после GROUP BY, но перед ORDER BY (при наличии).

SELECT col1, col2, ...colN
FROM table1, table2, ...tableN
[WHERE condition]
GROUP BY col1, col2, ...colN
HAVING condition
ORDER BY col1, col2, ...colN;

Транзакции
Транзакция - это единица работы или операции, выполняемой над БД. Это последовательность операций, выполняемых в логическом порядке. Эти операции могут запускаться как пользователем, так и какой-либо программой, функционирующей в БД.

Транзакция - это применение одного или более изменения к БД. Например, при создании/обновлении/удалении записи мы выполняем транзакцию. Важно контролировать выполнение таких операций в целях обеспечения согласованности данных и обработки возможных ошибок.

На практике, запросы, как правило, не отправляются в БД по одному, они группируются и выполняются как часть транзакции.

Свойства транзакции

Транзакции имеют 4 стандартных свойства (ACID):

атомарность (atomicity) - все операции транзакции должны быть успешно завершены. В противном случае, транзакция прерывается, а все изменения отменяются (происходит откат к предыдущему состоянию)
согласованность (consistency) - состояние должно изменться в полном соответствии с операциями транзакции
изоляция или автономность (isolation) - транзакции не зависят друг от друга и не оказывают друг на друга никакого влияния
долговечность (durability) - результат звершенной транзакции должен сохраняться при поломке системы
Управление транзакцией

Для управления транзакцией используются следующие команды:

BEGIN|START TRANSACTION - запуск транзакции
COMMIT - сохранение изменений
ROLLBACK - отмена изменений
SAVEPOINT - контрольная точка для отмены изменений
SET TRANSACTION - установка характеристик текущей транзакции
Команды для управления транзакцией могут использоваться только совместно с такими запросами как INSERT, UPDATE и DELETE. Они не могут использоваться во время создания и удаления таблиц, поскольку эти операции автоматически отправляются в БД.

Удаляем пользователя, возраст которого составляет 26 лет, и отправляем изменения в БД:

BEGIN TRANSACTION
DELETE FROM users
WHERE age = 26;
COMMIT;

Удаляем пользователя с именем Oleg и отменяем эту операцию:

BEGIN
  DELETE FROM users
  WHERE username = 'Oleg';
ROLLBACK;

Контрольные точки создаются с помощью такого синтаксиса:

SAVEPOINT savepointName;

Возврат к контрольной точке выполняется так:

ROLLBACK TO savepointName;

Выполняем три запроса на удаление данных из users, создавая контрольные точки перед каждый удалением:

START TRANSACTION
SAVEPOINT sp1;
DELETE FROM users
WHERE age = 26;

SAVEPOINT sp2;
DELETE FROM users
WHERE userName = 'Oleg';

SAVEPOINT sp3;
DELETE FROM users
WHERE status = 'inactive';

Отменяем два последних удаления, возвращаясь к контрльной точке sp2, созданной после первого удаления:

ROLLBACK TO sp2;

Делаем выборку пользователей:

SELECT * FROM users;

Результат:

userId	userName	age	city	status
1	Igor	31	Moscow	active
3	Elena	27	Ekaterinburg	active
4	Oleg	28	Moscow	inactive
Как видим, из таблицы был удален только пользователь с возрастом 26 лет.

Для удаление контрольной точки используется команда RELEASE SAVEPOINT. Естественно, после удаления контрольной точки, к ней нельзя будет вернуться с помощью ROLLBACK TO.

Команда SET TRANSACTION используется для инициализации транзакции, т.е. начала ее выполнения. При этом, можно определять некоторые характеристики транзакции. Например, так можно определить уровень доступа транзакции (доступна только для чтения или для записи тоже):

SET TRANSACTION [READ WRITE | READ ONLY];

Временные таблицы
Некоторые СУБД поддерживают так называемые временные таблицы (temporary tables). Такие таблицы позволяют хранить и обрабатывать промежуточные результаты с помощью таких же запросов, как и при работе с обычными таблицами.

Временные таблицы могут быть очень полезными при необходимости хранения временных данных. Одной из главных особенностей таких таблиц является то, что они удаляются по завершении текущей сессии. При запуске скрипта временная таблица удаляется после завершения выполнения этого скрипта. При доступе к БД с помощью клиентской программы, такая таблица будет удалена после закрытия этой программы.

Временная таблица создается с помощью инструкции CREATE TEMPORARY TABLE, в остальном синтаксис создания таких таблиц идентичен синтаксису создания обычных таблиц.

Временная таблица удаляется точно также, как и обычная таблица, с помощью инструкции DROP TABLE.

Клонирование таблицы
Может возникнуть ситуация, когда потребуется получить точную копию существующей таблицы, а CREATE TABLE или SELECT окажется недостаточно в силу того, что мы хотим получить не только идентичную структуру, но также индексы, значения по умолчанию и т.д. копируемой таблицы.

В mysql, например, это можно сделать так:

вызываем команду SHOW CREATE TABLE для получения инструкции, выполненной при создании таблицы, включая индексы и прочее
меняем название таблицы и выполняем запрос. Получаем точную копию таблицы
опционально: если требуется содержимое копируемой таблицы, можно также использовать инструкции INSERT INTO или SELECT
Подзапросы
Подзапрос - это внутренний (вложенный) запрос другого запроса, встроенный (вставленный) с помощью WHERE или других инструкций.

Подзапрос используется для получения данных, которые будут использованы основным запросом в качестве условия для фильтрации возвращаемых записей.

Подзапросы могут использоваться в инструкциях SELECT, INSERT, UPDATE и DELETE, а также с операторами =, <, >, >=, <=, IN, BETWEEN и т.д.

Правила использования подзапросов:

они должны быть обернуты в круглые скобки
подзапрос должен содержать только одну колонку для выборки, если основной запрос не содержит несколько таких колонок, которые сравниваются в подзапросе
в подзапросе нельзя использовать команду ORDER BY, это можно сделать в основном запросе. В подзапросе для замены ORDER BY можно использовать GROUP BY
подзапросы, возвращающие несколько значений, могут использоваться только с операторами, которые работают с наборами значений, такими как IN
список SELECT не может содержать ссылки на значения, которые оцениваются (вычисляются) как BLOB, ARRAY, CLOB или NCLOB
подзапрос не может быть сразу передан в функцию для установки значений
команду BETWEEN нельзя использовать совместно с подзапросом. Тем не менее, в самомподзапросе указанную команду использовать можно
Подзапросы, обычно, используются в инструкции SELECT.

SELECT col1, col2, ...colN
FROM table1, table2, ...tableN
WHERE colName operator
  (SELECT col1, col2, ...colN
  FROM table1, table2, tableN
  [WHERE condition]);

Пример:

SELECT * FROM users
WHERE userId IN (
  SELECT userId FROM users
  WHERE status = 'active'
);

Результат:

userId	userName	age	city	status
1	Igor	30	Moscow	active
3	Elena	27	Ekaterinburg	active
Подзапросы могут использоваться в инструкции INSERT. Эта инструкция добавляет в таблицу данные, возвращаемые подзапросом. При этом, данные, возвращаемые подзапросом, могут быть модифицированы любыми способами.

INSERT INTO tableName col1, col2, ...colN
SELECT col1, col2, ...colN
FROM table1, table2, ...tableN
[WHERE operator [value]];

Подзапросы могут использоваться в инструкции UPDATE. При этом, данные из подзапроса могут использоваться для обновления любого количества колонок.

UPDATE tableName
SET col = newVal
[WHERE operator [value]
  (
    SELECT colName
    FROM tableName
    [WHERE condition]
  )
];

Данные, возвращаемые подзапросом, могут использоваться и для удаления записей.

DELETE FROM tableName
[WHERE operator [value]
  (
    SELECT colName
    FROM tableName
    [WHERE condition]
  )
];

Последовательности
Последовательность - это набор целых чисел (1, 2, 3 и т.д.), генерируемых автоматически. Последовательности часто используются в БД, поскольку многие приложения нуждаются в уникальных значениях, используемых для идентификации строк.

Приведенные ниже примеры рассчитаны на mysql.

Простейшим способом определения последовательности является использование AUTO_INCREMENT при создании таблицы:

CREATE TABLE tableName (
  id INT UNSIGNED NOT NULL AUTO_INCREMENT,
  PRIMARY KEY (id),
  -- другие строки
);

Для того, чтобы заново пронумеровать строки с помощью автоматически генерируемых значений (например, при удалении большого количества строк), можно удалить колонку, содержащую такие значения и создать ее заново. Обратите внимание: такая таблица не должна быть частью объединения.

ALTER TABLE tableName DROP id;
ALTER TABLE tableName
ADD id INT UNSIGNED NOT NULL AUTO_INCREMENT FIRST,
ADD PRIMARY KEY (id);

По умолчанию значения, генерируемые с помощью AUTO_INCREMENT, начинаются с 1. Для того, чтобы установить другое начальное значение достаточно указать, например, AUTO_INCREMENT = 100 - в этом случае нумерация строк начнется со 100.



Триггер — это специальный вид хранимой процедуры, который автоматически выполняется (срабатывает) при определённых событиях в базе данных, например, при INSERT, UPDATE или DELETE.


CREATE TRIGGER trgAfterInsertEmployee
ON Employees
AFTER INSERT
AS
BEGIN
    PRINT 'Новый сотрудник добавлен';
END;


CREATE TRIGGER trgInsteadOfUpdate
ON Employees
INSTEAD OF UPDATE
AS
BEGIN
    IF UPDATE(Salary)
    BEGIN
        PRINT 'Изменение зарплаты запрещено через этот триггер.';
        RETURN;
    END
    ELSE
    BEGIN
        -- Если не Salary — разрешаем обновление
        UPDATE e
        SET e.Name = i.Name
        FROM Employees e
        INNER JOIN inserted i ON e.EmployeeID = i.EmployeeID;
    END
END;


CREATE TABLE EmployeeAudit (
    AuditID INT IDENTITY PRIMARY KEY,
    EmployeeID INT,
    OldSalary DECIMAL(10,2),
    NewSalary DECIMAL(10,2),
    ChangeDate DATETIME
);

CREATE TRIGGER trgLogSalaryChange
ON Employees
AFTER UPDATE
AS
BEGIN
    IF UPDATE(Salary)
    BEGIN
        INSERT INTO EmployeeAudit (EmployeeID, OldSalary, NewSalary, ChangeDate)
        SELECT i.EmployeeID, d.Salary, i.Salary, GETDATE()
        FROM inserted i
        JOIN deleted d ON i.EmployeeID = d.EmployeeID;
    END
END;

CREATE TRIGGER trgNoDropTable
ON DATABASE
FOR DROP_TABLE
AS
BEGIN
    PRINT 'Удаление таблиц запрещено!';
    ROLLBACK;
END;

CREATE TRIGGER trgLogonAudit
ON ALL SERVER
FOR LOGON
AS
BEGIN
    IF ORIGINAL_LOGIN() = 'BadUser'
    BEGIN
        ROLLBACK;
        PRINT 'Вход запрещён для BadUser';
    END
END;

--------------------------------------------------------------------------------

CREATE TABLE Patient (
	patient_id int PRIMARY KEY identity,
	fullname nvarchar(60) not null,
	birthday DATETIME not null,
	phone NVARCHAR(20),
	address nvarchar(100)
);
GO

CREATE TABLE Specialty(
	specialty_id int PRIMARY KEY identity,
	specialty_name nvarchar(100) not null unique
);
GO

CREATE TABLE Doctor(
    doctor_id int PRIMARY KEY identity,
    fullname nvarchar(60) not null,
    specialty_id int not null,
    base_rate DECIMAL(10, 2) NOT NULL,
    commission_percent DECIMAL(5, 2) NOT NULL,
    FOREIGN KEY (specialty_id) REFERENCES Specialty(specialty_id)
);
GO

CREATE TABLE Appointment (
    appointment_id INT PRIMARY KEY IDENTITY,
    patient_id INT NOT NULL,
    doctor_id INT NOT NULL,
    appointment_date DATETIME NOT NULL,
    rate DECIMAL(10, 2) NOT NULL,
    commission_percent DECIMAL(5, 2) NOT NULL,
    FOREIGN KEY (patient_id) REFERENCES Patient(patient_id),
    FOREIGN KEY (doctor_id) REFERENCES Doctor(doctor_id)
);
GO

CREATE TABLE Users (
    user_id INT PRIMARY KEY IDENTITY,
    username NVARCHAR(50) NOT NULL UNIQUE,
    password_hash NVARCHAR(255) NOT NULL,
    role NVARCHAR(7) NOT NULL CHECK (Role IN ('Admin', 'Doctor')), 
    doctor_id INT NULL,
    FOREIGN KEY (doctor_id) REFERENCES Doctor(doctor_id)
);


-- 1. Представление: Детали всех приемов с информацией о пациенте и враче
CREATE VIEW AppointmentDetails AS
SELECT 
    a.appointment_id,
    p.fullname AS patient_name,
    d.fullname AS doctor_name,
    s.specialty_name,
    a.appointment_date,
    a.rate,
    a.commission_percent,
    (a.rate * a.commission_percent / 100) * 0.87 AS net_salary
FROM Appointment a
JOIN Patient p ON a.patient_id = p.patient_id
JOIN Doctor d ON a.doctor_id = d.doctor_id
JOIN Specialty s ON d.specialty_id = s.specialty_id;
GO

-- 2. Триггер: Автоматическое создание квитанции при добавлении приема
CREATE TRIGGER trg_CreateReceiptOnAppointment
ON Appointment
AFTER INSERT
AS
BEGIN
    INSERT INTO Receipt (appointment_id, issue_date, amount)
    SELECT 
        i.appointment_id,
        GETDATE(),
        i.rate
    FROM inserted i;
END;
GO

-- 3. Хранимая процедура: Запись пациента на прием
CREATE PROCEDURE sp_CreateAppointment
    @patient_id INT,
    @doctor_id INT,
    @appointment_date DATETIME,
    @appointment_id INT OUTPUT
AS
BEGIN
    DECLARE @base_rate DECIMAL(10,2);
    DECLARE @commission_percent DECIMAL(5,2);

    -- Получаем данные врача
    SELECT 
        @base_rate = base_rate,
        @commission_percent = commission_percent
    FROM Doctor WHERE doctor_id = @doctor_id;

    -- Создаем запись о приеме
    INSERT INTO Appointment (
        patient_id, 
        doctor_id, 
        appointment_date, 
        rate, 
        commission_percent
    ) VALUES (
        @patient_id, 
        @doctor_id, 
        @appointment_date, 
        @base_rate, 
        @commission_percent
    );

    SET @appointment_id = SCOPE_IDENTITY();
END;
GO

-- 4. Функция: Расчет чистой зарплаты врача за прием
CREATE FUNCTION dbo.CalculateDoctorSalary (
    @rate DECIMAL(10,2),
    @commission_percent DECIMAL(5,2)
)
RETURNS DECIMAL(10,2)
AS
BEGIN
    DECLARE @salary DECIMAL(10,2);
    SET @salary = (@rate * @commission_percent / 100) * 0.87;
    RETURN @salary;
END;
GO

-- 5. Представление: Статистика по врачам по месяцам
CREATE VIEW DoctorMonthlyStats AS
SELECT 
    d.doctor_id,
    d.fullname AS doctor_name,
    s.specialty_name,
    FORMAT(a.appointment_date, 'yyyy-MM') AS month_year,
    COUNT(a.appointment_id) AS total_appointments,
    SUM(a.rate) AS total_revenue,
    SUM(dbo.CalculateDoctorSalary(a.rate, a.commission_percent)) AS total_salary
FROM Appointment a
JOIN Doctor d ON a.doctor_id = d.doctor_id
JOIN Specialty s ON d.specialty_id = s.specialty_id
GROUP BY 
    d.doctor_id, 
    d.fullname, 
    s.specialty_name, 
    FORMAT(a.appointment_date, 'yyyy-MM');
GO

--------------------------------------------------------------------------------




using Microsoft.Data.SqlClient;
using System.Data;
using Test_Kursovoi.Services;
using Dapper;
using System.Text.RegularExpressions;
using Test_Kursovoi.Models;
using System.Text;
using System.Security.Cryptography;
using Test_Kursovoi.Forms;

namespace Test_Kursovoi
{
    public partial class MainForm : Form
    {
        private string currentTableName = "";
        private string currentPrimaryKey = "";
        private enum EditMode { None, Add, Edit }
        private EditMode currentEditMode = EditMode.None;
        private object currentEditId = null;
        private Dictionary<string, string> columnTypes = new();
        private readonly User _currentUser;

        public MainForm()
        {
            new LoginForm().ShowDialog();
            InitializeComponent();
            Close();
        }

        public MainForm(User user)
        {
            InitializeComponent();
            InitializeCustomComponents();
            comboBox1.Items.Add("223");
            _currentUser = user;
            label1.Text = $"Добро пожаловать, {_currentUser.username}! Роль: {_currentUser.role}";

            if (_currentUser.role == "doctor")
            {
                comboBox1.Items.Add("223");
            }
        }

        private void MainForm_Load(object sender, EventArgs e) { }

        private void InitializeCustomComponents()
        {
            LoadData("SELECT * FROM Users", "Users");
            dataGridView1.SelectionChanged += DataGridView_SelectionChanged;
        }

        public void LoadData(string query, string tableName)
        {
            if (!Regex.IsMatch(tableName, @"^[a-zA-Z0-9_]+$"))
            {
                MessageBox.Show("Недопустимое имя таблицы.");
                return;
            }

            try
            {
                currentTableName = tableName;
                currentPrimaryKey = GetPrimaryKeyName(tableName);
                columnTypes = GetColumnTypes(tableName);

                string safeQuery = $"SELECT * FROM [{tableName}]";
                dataGridView1.DataSource = DBServices.GetTable(safeQuery);
            }
            catch (Exception ex)
            {
                MessageBox.Show($"Ошибка загрузки таблицы: {ex.Message}");
            }
        }

        private string GetPrimaryKeyName(string tableName)
        {
            const string query = @"
                SELECT COLUMN_NAME
                FROM INFORMATION_SCHEMA.KEY_COLUMN_USAGE
                WHERE OBJECTPROPERTY(OBJECT_ID(CONSTRAINT_SCHEMA + '.' + QUOTENAME(CONSTRAINT_NAME)), 'IsPrimaryKey') = 1
                AND TABLE_NAME = @TableName";

            using var conn = new SqlConnection(DBServices.connectionString);
            using var cmd = new SqlCommand(query, conn);
            cmd.Parameters.AddWithValue("@TableName", tableName);
            conn.Open();
            return cmd.ExecuteScalar()?.ToString() ?? "";
        }

        private Dictionary<string, string> GetColumnTypes(string tableName)
        {
            var types = new Dictionary<string, string>();
            const string query = @"
                SELECT COLUMN_NAME, DATA_TYPE
                FROM INFORMATION_SCHEMA.COLUMNS
                WHERE TABLE_NAME = @TableName";

            using var conn = new SqlConnection(DBServices.connectionString);
            using var cmd = new SqlCommand(query, conn);
            cmd.Parameters.AddWithValue("@TableName", tableName);
            conn.Open();
            using var reader = cmd.ExecuteReader();
            while (reader.Read())
                types[reader.GetString(0)] = reader.GetString(1);
            return types;
        }

        private void DataGridView_SelectionChanged(object sender, EventArgs e)
        {
            if (dataGridView1.CurrentRow == null || dataGridView1.CurrentRow.IsNewRow)
            {
                ClearFields();
                return;
            }

            var selectedRow = (DataRowView)dataGridView1.CurrentRow.DataBoundItem;
            currentEditMode = EditMode.Edit;
            currentEditId = selectedRow[currentPrimaryKey];

            flowLayoutPanel1.Controls.Clear();

            foreach (DataColumn column in selectedRow.DataView.Table.Columns)
            {
                if (column.ColumnName == currentPrimaryKey) continue;

                Label label = new Label() { Text = column.ColumnName, Width = 100 };
                Control input;

                string type = columnTypes.ContainsKey(column.ColumnName) ? columnTypes[column.ColumnName] : "nvarchar";

                if (type.Contains("date"))
                {
                    input = new DateTimePicker()
                    {
                        Tag = column.ColumnName,
                        Value = DateTime.TryParse(selectedRow[column.ColumnName]?.ToString(), out var dt) ? dt : DateTime.Now
                    };
                }
                else
                {
                    input = new TextBox()
                    {
                        Tag = column.ColumnName,
                        Text = selectedRow[column.ColumnName]?.ToString()
                    };
                }

                flowLayoutPanel1.Controls.Add(label);
                flowLayoutPanel1.Controls.Add(input);
            }

            Button btnDelete = new Button() { Text = "Удалить" };
            Button btnAdd = new Button() { Text = "Добавить" };
            Button btnUpdate = new Button() { Text = "Обновить" };

            btnDelete.Click += (s, ev) => DeleteRecord(selectedRow);
            btnAdd.Click += (s, ev) => AddRecord();
            btnUpdate.Click += (s, ev) => UpdateRecord(selectedRow);

            flowLayoutPanel1.Controls.Add(btnDelete);
            flowLayoutPanel1.Controls.Add(btnAdd);
            flowLayoutPanel1.Controls.Add(btnUpdate);
        }

        private void ClearFields()
        {
            flowLayoutPanel1.Controls.Clear();

            foreach (DataGridViewColumn column in dataGridView1.Columns)
            {
                if (column.Name == currentPrimaryKey) continue;

                Label label = new Label() { Text = column.Name, Width = 100 };

                Control input;
                string type = columnTypes.ContainsKey(column.Name) ? columnTypes[column.Name] : "nvarchar";

                if (type.Contains("date"))
                {
                    input = new DateTimePicker()
                    {
                        Tag = column.Name,
                        Value = DateTime.Now
                    };
                }
                else
                {
                    input = new TextBox() { Tag = column.Name };
                }

                flowLayoutPanel1.Controls.Add(label);
                flowLayoutPanel1.Controls.Add(input);
            }

            Button btnAdd = new Button() { Text = "Добавить" };
            btnAdd.Click += (s, e) => AddRecord();
            flowLayoutPanel1.Controls.Add(btnAdd);
        }

        private void AddRecord()
        {
            var parameters = new DynamicParameters();
            var columns = new List<string>();
            var values = new List<string>();

            foreach (Control control in flowLayoutPanel1.Controls)
            {
                if (control.Tag is not string columnName) continue;
                if (columnName == currentPrimaryKey) continue;

                columns.Add(columnName);
                values.Add($"@{columnName}");

                if (control is DateTimePicker picker)
                    parameters.Add($"@{columnName}", picker.Value);
                else if (control is TextBox textBox)
                    parameters.Add($"@{columnName}", textBox.Text);
            }

            if (!columns.Any()) return;

            string query = $"INSERT INTO {currentTableName} ({string.Join(", ", columns)}) VALUES ({string.Join(", ", values)})";

            try
            {
                using var conn = new SqlConnection(DBServices.connectionString);
                conn.Execute(query, parameters);
                ReloadCurrentTable();
            }
            catch (Exception ex)
            {
                MessageBox.Show($"Ошибка добавления: {ex.Message}");
            }
        }

        private void UpdateRecord(DataRowView selectedRow)
        {
            var values = new Dictionary<string, string>();
            foreach (Control control in flowLayoutPanel1.Controls)
            {
                if (control.Tag is not string columnName || columnName == currentPrimaryKey) continue;

                string value = control switch
                {
                    DateTimePicker picker => picker.Value.ToString("yyyy-MM-dd"),
                    TextBox textBox => textBox.Text,
                    _ => ""
                };

                values[columnName] = value;
            }

            if (selectedRow[currentPrimaryKey] is int id)
                UpdateRecord(currentTableName, values, currentPrimaryKey, id);
        }

        public void UpdateRecord(string tableName, Dictionary<string, string> values, string idColumn, int id)
        {
            var parameters = new DynamicParameters();
            var setClauses = new List<string>();

            foreach (var kvp in values)
            {
                setClauses.Add($"{kvp.Key} = @{kvp.Key}");

                if (DateTime.TryParse(kvp.Value, out var dateVal))
                    parameters.Add($"@{kvp.Key}", dateVal);
                else
                    parameters.Add($"@{kvp.Key}", kvp.Value);
            }

            parameters.Add("@Id", id);
            string query = $"UPDATE {tableName} SET {string.Join(", ", setClauses)} WHERE {idColumn} = @Id";

            try
            {
                using var conn = new SqlConnection(DBServices.connectionString);
                conn.Execute(query, parameters);
                ReloadCurrentTable();
            }
            catch (Exception ex)
            {
                MessageBox.Show($"Ошибка обновления: {ex.Message}");
            }
        }

        private void DeleteRecord(DataRowView row)
        {
            string id = row[currentPrimaryKey].ToString();
            string query = $"DELETE FROM {currentTableName} WHERE {currentPrimaryKey} = @{currentPrimaryKey}";

            try
            {
                var param = new SqlParameter($"@{currentPrimaryKey}", id);
                DBServices.ExecuteQuery(query, new[] { param });
                ReloadCurrentTable();
            }
            catch (Exception ex)
            {
                MessageBox.Show($"Ошибка удаления: {ex.Message}");
            }
        }

        private void ReloadCurrentTable()
        {
            try
            {
                string query = $"SELECT * FROM [{currentTableName}]";
                dataGridView1.DataSource = DBServices.GetTable(query);
            }
            catch (Exception ex)
            {
                MessageBox.Show($"Ошибка загрузки таблицы: {ex.Message}");
            }
        }

        private void generateHashBtn_Click(object sender, EventArgs e)
        {
            string password = textBox1.Text;

            textBox2.Text = HashPassword(password);
        }

        private string HashPassword(string password)
        {
            using (SHA256 sha256 = SHA256.Create())
            {
                byte[] inputBytes = Encoding.UTF8.GetBytes(password);
                byte[] hashBytes = sha256.ComputeHash(inputBytes);

                StringBuilder builder = new StringBuilder();
                for (int i = 0; i < hashBytes.Length; i++)
                {
                    builder.Append(hashBytes[i].ToString("x2")); // "x2" — преобразует байт в шестнадцатеричное представление
                }

                return builder.ToString();
            }
        }
    }
}




using Microsoft.Data.SqlClient;
using Dapper;
using Test_Kursovoi.Models;
using Test_Kursovoi.Services;
using System.Text;
using System.Security.Cryptography;

namespace Test_Kursovoi.Forms
{
    public partial class LoginForm : Form
    {
        public LoginForm()
        {
            InitializeComponent();
        }

        private void btnLogin_Click(object sender, EventArgs e)
        {
            string username = Login.Text.Trim();
            string password = PasswordHash.Text.Trim();

            if (string.IsNullOrEmpty(username) || string.IsNullOrEmpty(password))
            {
                MessageBox.Show("Введите логин и пароль", "Ошибка", MessageBoxButtons.OK, MessageBoxIcon.Warning);
                return;
            }

            try
            {
                using (var connection = new SqlConnection(DBServices.connectionString))
                {
                    var user = connection.QueryFirstOrDefault<User>(
                        "SELECT * FROM Users WHERE username = @username",
                        new { username });

                    if (user == null)
                    {
                        MessageBox.Show("Пользователь не найден", "Ошибка", MessageBoxButtons.OK, MessageBoxIcon.Warning);
                        return;
                    }

                    // Проверка пароля через SHA256
                    if (PasswordHasher.Verify(password, user.password_hash))
                    {
                        // Авторизация успешна
                        Hide();
                        var mainForm = new MainForm(user);
                        mainForm.ShowDialog();
                    }
                    else
                    {
                        MessageBox.Show("Неверный логин или пароль", "Ошибка", MessageBoxButtons.OK, MessageBoxIcon.Error);
                    }
                }
            }
            catch (Exception ex)
            {
                MessageBox.Show($"Ошибка при входе: {ex.Message}", "Ошибка", MessageBoxButtons.OK, MessageBoxIcon.Error);
            }
        }

        private void LoginForm_FormClosed(object sender, FormClosedEventArgs e)
        {
            Application.Exit();
        }
    }

    public static class PasswordHasher
    {
        public static string Hash(string password)
        {
            using var sha256 = SHA256.Create();
            var bytes = Encoding.UTF8.GetBytes(password);
            var hashBytes = sha256.ComputeHash(bytes);

            // Преобразуем байты в HEX строку
            StringBuilder builder = new StringBuilder();
            foreach (var b in hashBytes)
            {
                builder.Append(b.ToString("x2")); // шестнадцатеричный формат
            }

            return builder.ToString();
        }

        public static bool Verify(string rawPassword, string storedHash)
        {
            string hashedInput = Hash(rawPassword);
            return hashedInput.Equals(storedHash);
        }
    }
}


namespace Test_Kursovoi.Forms
{
    partial class LoginForm
    {
        /// <summary>
        /// Required designer variable.
        /// </summary>
        private System.ComponentModel.IContainer components = null;

        /// <summary>
        /// Clean up any resources being used.
        /// </summary>
        /// <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        protected override void Dispose(bool disposing)
        {
            if (disposing && (components != null))
            {
                components.Dispose();
            }
            base.Dispose(disposing);
        }

        #region Windows Form Designer generated code

        /// <summary>
        /// Required method for Designer support - do not modify
        /// the contents of this method with the code editor.
        /// </summary>
        private void InitializeComponent()
        {
            label1 = new Label();
            PasswordHash = new TextBox();
            Login = new TextBox();
            label3 = new Label();
            label2 = new Label();
            LoginBtn = new Button();
            SuspendLayout();
            // 
            // label1
            // 
            label1.AutoSize = true;
            label1.Font = new Font("Verdana", 14.25F, FontStyle.Regular, GraphicsUnit.Point, 204);
            label1.Location = new Point(136, 9);
            label1.Name = "label1";
            label1.Size = new Size(136, 23);
            label1.TabIndex = 0;
            label1.Text = "Авторизация";
            // 
            // PasswordHash
            // 
            PasswordHash.Font = new Font("Verdana", 12F);
            PasswordHash.Location = new Point(109, 143);
            PasswordHash.Name = "PasswordHash";
            PasswordHash.Size = new Size(200, 27);
            PasswordHash.TabIndex = 32;
            // 
            // Login
            // 
            Login.Font = new Font("Verdana", 12F);
            Login.Location = new Point(109, 74);
            Login.Name = "Login";
            Login.Size = new Size(200, 27);
            Login.TabIndex = 31;
            // 
            // label3
            // 
            label3.AutoSize = true;
            label3.Font = new Font("Verdana", 12F);
            label3.Location = new Point(109, 122);
            label3.Name = "label3";
            label3.Size = new Size(85, 18);
            label3.TabIndex = 30;
            label3.Text = "Password";
            // 
            // label2
            // 
            label2.AutoSize = true;
            label2.Font = new Font("Verdana", 12F);
            label2.Location = new Point(109, 53);
            label2.Name = "label2";
            label2.Size = new Size(52, 18);
            label2.TabIndex = 29;
            label2.Text = "Login";
            // 
            // LoginBtn
            // 
            LoginBtn.Font = new Font("Verdana", 12F, FontStyle.Regular, GraphicsUnit.Point, 204);
            LoginBtn.Location = new Point(159, 208);
            LoginBtn.Name = "LoginBtn";
            LoginBtn.Size = new Size(82, 36);
            LoginBtn.TabIndex = 33;
            LoginBtn.Text = "Войти";
            LoginBtn.UseVisualStyleBackColor = true;
            LoginBtn.Click += btnLogin_Click;
            // 
            // LoginForm
            // 
            AutoScaleDimensions = new SizeF(7F, 15F);
            AutoScaleMode = AutoScaleMode.Font;
            ClientSize = new Size(408, 315);
            Controls.Add(LoginBtn);
            Controls.Add(PasswordHash);
            Controls.Add(Login);
            Controls.Add(label3);
            Controls.Add(label2);
            Controls.Add(label1);
            Name = "LoginForm";
            StartPosition = FormStartPosition.CenterScreen;
            Text = "Login";
            FormClosed += LoginForm_FormClosed;
            ResumeLayout(false);
            PerformLayout();
        }

        #endregion

        private Label label1;
        private TextBox PasswordHash;
        private TextBox Login;
        private Label label3;
        private Label label2;
        private Button LoginBtn;
    }
}
		</textarea>
	</body>
</html>
